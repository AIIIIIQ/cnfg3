# Учебный конфигурационный язык - Парсер

## 1. Общее описание

Данный проект представляет собой инструмент командной строки для парсинга учебного конфигурационного языка и преобразования его в формат JSON. Инструмент читает входной файл с конфигурацией на специальном языке, обнаруживает синтаксические ошибки и выводит результат в виде JSON-файла.

**Особенности:**

- **Поддержка основных конструкций языка:**
  - Однострочные (`%`) и многострочные (`--[[ ... ]]--`) комментарии.
  - Объявление констант на этапе трансляции (`var NAME := value;`).
  - Вычисление констант (`|NAME|`).
  - Массивы и словари.
- **Выявление синтаксических ошибок** с выводом понятных сообщений.
- **Покрытие тестами** всех конструкций языка и возможных ошибок.

## 2. Описание всех функций и настроек

### Класс `ConfigParser`

Основной класс, отвечающий за парсинг конфигурационного файла.

#### Атрибуты:

- `self.constants`: Словарь для хранения объявленных констант.
- `self.tokens`: Список токенов, полученных после токенизации входного текста.
- `self.pos`: Текущая позиция в списке токенов при парсинге.

#### Методы:

- `tokenize(self, text)`: Токенизирует входной текст, удаляя комментарии и разбивая текст на токены.

  - **Описание процесса:**
    - Удаление однострочных (`% ...`) и многострочных (`--[[ ... ]]--`) комментариев.
    - Определение спецификации токенов (числа, имена, ключевые слова, операторы и т.д.).
    - Использование регулярных выражений для разбора текста на токены.
    - Обработка токенов и добавление их в `self.tokens`.

- `parse(self)`: Запускает процесс парсинга токенов и возвращает результирующую структуру данных.

  - **Описание процесса:**
    - Инициализация пустого списка результатов.
    - Последовательный вызов `parse_value()` для каждого токена.
    - Возврат единственного результата или списка результатов.

- `parse_value(self)`: Парсит значение на основе текущего токена.

  - **Описание процесса:**
    - Проверяет текущий токен и вызывает соответствующий метод парсинга:
      - `parse_var()` для объявления константы.
      - `parse_eval()` для вычисления константы.
      - `parse_assignment()` для присваивания значения имени.
      - Возвращает число, массив или словарь в зависимости от токена.

- `parse_assignment(self)`: Парсит присваивание значения имени (e.g., `NAME = value`).

- `parse_array(self)`: Парсит массив (e.g., `(value, value, ...)`) и возвращает список.

- `parse_dict(self)`: Парсит словарь (e.g., `{ NAME = value ... }`) и возвращает словарь.

- `parse_var(self)`: Парсит объявление константы (e.g., `var NAME := value;`) и сохраняет ее в `self.constants`.

- `parse_eval(self)`: Парсит вычисление константы (e.g., `|NAME|`) и возвращает ее значение из `self.constants`.

- `match(self, kind)`: Проверяет, соответствует ли текущий токен ожидаемому типу `kind`.

- `consume(self, kind)`: Потребляет текущий токен, если он соответствует типу `kind`, и продвигает позицию `self.pos`.

### Функция `main()`

- Обрабатывает аргументы командной строки (`-i` для входного файла и `-o` для выходного файла).
- Читает входной файл, инициирует парсер и запускает процесс парсинга.
- Обрабатывает исключения и выводит сообщения об ошибках.

## 3. Описание команд для сборки проекта

Для запуска парсера вам понадобится установленный Python версии 3.6 или выше.

**Команды для запуска парсера:**

```bash
python config_parser.py -i <входной_файл> -o <выходной_файл>
```

**Примеры:**

- Парсинг файла `test1.cfg` и сохранение результата в `output1.json`:

  ```bash
  python config_parser.py -i test1.cfg -o output1.json
  ```

- Парсинг файла `web_server.cfg` и сохранение результата в `web_server.json`:

  ```bash
  python config_parser.py -i web_server.cfg -o web_server.json
  ```

Запустите сценарий двойным щелчком или командой:

```cmd
run_tests.cmd
```

## 4. Результаты прогона тестов

После запуска сценария `run_tests.cmd` вы получите следующий вывод в консоли:

```
==========================================
Running test1.cfg...
Parsing completed successfully.

==========================================
Running test2.cfg...
Parsing completed successfully.

==========================================
Running test3.cfg...
Error: Expected comma or right parenthesis

==========================================
Running test4.cfg...
Error: Undefined constant UNDEFINEDCONST

==========================================
Running test5.cfg...
Error: Unexpected character _

==========================================
Running test6.cfg...
Error: Expected EQUAL

==========================================
Running test7.cfg...
Error: Expected ASSIGN

==========================================
Running test8.cfg...
Error: Expected SEMICOLON

==========================================
Running test9.cfg...
Error: Expected comma or right parenthesis

==========================================
Running test10.cfg...
Error: Expected comma or right parenthesis

==========================================
Running test11.cfg...
Error: Expected a name or closing brace

==========================================
Running test12.cfg...
Error: Expected a name

==========================================
Running test13.cfg...
Error: Expected a value

==========================================
Running test14.cfg...
Error: Expected a name after var

==========================================
Running test15.cfg...
Error: Expected a name after |

==========================================
Running test16.cfg...
Parsing completed successfully.

==========================================
Running test17.cfg...
Error: Unexpected character @

==========================================
Running web_server.cfg...
Parsing completed successfully.

==========================================
Running experiment.cfg...
Parsing completed successfully.

All tests have been executed.
```

**Объяснение результатов:**

- **Успешные тесты:**
  - `test1.cfg`, `test2.cfg`, `test16.cfg`, `web_server.cfg`, `experiment.cfg` успешно обработаны парсером.
- **Тесты с ошибками:**
  - Остальные тесты вызвали ожидаемые ошибки, проверяющие обработку парсером различных синтаксических и семантических ошибок.

**Примеры выходных файлов:**

- **`output1.json`:**

  ```json
  10
  ```

- **`output2.json`:**

  ```json
  {
      "DATA": {
          "NUMBER": 42,
          "ARRAY": [1, 2, 3, [4, 5]],
          "DICT": {
              "KEY": 100,
              "NESTEDARRAY": [6, 7, 8]
          }
      }
  }
  ```

- **`web_server.json`:**

  ```json
  {
      "SERVERCONFIG": {
          "HOST": 127001,
          "PORT": 8080,
          "ENABLESSL": 0,
          "SUPPORTEDMETHODS": [1, 2, 3]
      }
  }
  ```

- **`experiment.json`:**

  ```json
  {
      "EXPERIMENT": {
          "NAME": 1,
          "PARAMETERS": {
              "DURATION": 120,
              "SAMPLERATE": 44100,
              "CHANNELS": 2
          },
          "NOTES": 0
      }
  }
  ```

**Выводы:**

- Парсер успешно обрабатывает все предусмотренные конструкции языка.
- Все синтаксические ошибки корректно выявляются и сопровождаются понятными сообщениями.
- Тесты обеспечивают полное покрытие функциональности парсера.

## Примечания

- Убедитесь, что все файлы сохранены в кодировке UTF-8.
- Скрипт разработан для работы на Python 3.6 и выше.
